<h2>Testing a service that makes HTTP calls</h2>

<section>
  <p>
    Angular provides us with a drop-in replacement for the HTTP service, which allows
    us to spy on requests and send mock responses, much like <code>$httpBackend</code> in
    AngularJS. And, just like <code>$httpBackend</code>, the new 
    <code>HttpTestingController</code> makes all its responses synchronously, greatly 
    simplifying testing.
  </p>

  <p>
    <code>HttpTestingController</code> lives in <code>HttpClientTestingModule</code>.
    You can import both from <code>@angular/common/http/testing</code>. You need to
    provide the module to the TestBed, and then you can grab a reference to the 
    controller.
  </p>
  <pre><code>import &#123; TestBed } from '@angular/core/testing';
  import &#123; HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

  import &#123; MyServiceThatIWantToTest } from './my.service';

  describe('MyServiceThatIWantToTest', () => &#123;
    let http: HttpTestingController;

    beforeEach(() => &#123;
      TestBed.configureTestingModule(&#123;
        imports:[ HttpClientTestingModule ]
      });

      http = TestBed.get(HttpTestingController);
    });

  });</code></pre>

  <p>
    Note we're using <code>imports</code> here, not <code>providers</code>. What's the 
    difference? Use <code>providers</code> to provide individual services. You can use
    <code>imports</code> to provide entire modules.
  </p>

  <p>And now we're ready to test stuff!</p>
</section>

<h2>Testing a request was made</h2>

<section>
  <p>
    We can test that a request to a specific URL was made using 
    HttpTestingController's <code>expectOne(url)</code> method. You just pass it the URL you're 
    expecting to be requested, some time after you've made the call. Try it out with the 
    <code>makeRequest</code> method of the <code>HttpService</code> in 
    <code>http.service.spec.ts</code>. (Yes, HttpService is a pretty rubbish name,
    I really should have called it something else, but naming things is hard).
    Don't forget you need to subscribe to the response from 
    <code>makeRequest</code>.
  </p>

  <app-hint-box>
    <span title>What are you talking about?</span>
    <div answer>
      <pre><code>describe('HttpService', () => &#123;
  let http: HttpTestingController;
  let service: HttpService;

  beforeEach(() => &#123;
    TestBed.configureTestingModule(&#123;
      imports:[ HttpClientTestingModule ]
    });

    http = TestBed.get(HttpTestingController);
    service = TestBed.get(HttpService);
  });

  ...

  it('should make a request', () => &#123;
    service.makeRequest().subscribe();
    http.expectOne('/foo');
  });
}        
      </code></pre>
    </div>
  </app-hint-box>

  <p>
    We can also check other details of the request, using the <code>request</code>
    property of the object returned by <code>expectOne</code>.
  </p>

  <pre><code>const details = http.expectOne('/feedback').request;</code></pre>

  <p><code>expectOne</code> returns the original HTTP request that was issued.</p>

  <p>
    You can use this to check that the sendFeedback method in 
    HTTPService is sending the correct request. You need to check that
  </p>

  <ul>
    <li>The HTTP method is POST</li>
    <li>It has an Authorization header with a value of 'totes legit'. For the securities.</li>
    <li>It is sending the following data</li>
  </ul>

  <pre>
    &#123;
      user: 'bender@planetexpress.com',
      feedback: 'destroy all humans',
      date: '3000-01-01'
    }
  </pre>

  <app-hint-box>
    <span title>That's a lot of things to check...</span>
    <div answer>
      <pre><code>
it('should send feedback', () => &#123;
  const feedback = &#123;
    user: 'bender@planetexpress.com',
    feedback: 'destroy all humans',
    date: '1/1/3000'
  }
  service.sendFeedback(feedback).subscribe();

  const details = http.expectOne('/feedback').request;
  expect(details.method).toBe('POST');
  expect(details.headers.get('Authorization')).toBe('totes legit');
  expect(details.body).toEqual(&#123;
    user: 'bender@planetexpress.com',
    feedback: 'destroy all humans',
    date: '3000-01-01'
  });
});      
      </code></pre>
    </div>
  </app-hint-box>
</section>

<h2>Testing a request wasn't made</h2>

<section>
  <p>
    You can also check that a request <em>wasn't</em> made.
    There are a couple of ways to do this.
  </p>

  <p>
    The most explicit is to use the <code>expectNone</code> method
    of the HttpTestingController. <code>expectNone</code> works just
    like <code>expectOne</code>, except it checks that the call 
    wasn't made. It's useful for situations where you want to 
    check that a request is only made if a certain condition is met.
  </p>

  <p>
    In our example, we want to make sure the feedback request is
    only made if the user has supplied us with an email address.
  </p>

  <app-hint-box>
    <span title>It wasn't not what?</span>
    <div answer>
      <pre><code>
it('should not send feedback if an email isn\'t supplied', () => &#123;
  const feedback = &#123;
    feedback: 'bite my shiny metal ass',
    date: '2/1/3000'
  };
  service.sendFeedback(feedback).subscribe();

  http.expectNone('/feedback');
});        
      </code></pre>
    </div>
  </app-hint-box>

  <p>
    The other way to check that a request wasn't made is to use
    the <code>verify()</code> method of the HttpTestingController.
    This is more of a generic clean-up, that checks that there are 
    no unexpected or outstanding requests.
  </p>

  <p>
    The usual way of using it is to stick it in an <code>afterEach</code>.
    Then, if any of your tests make an HTTP request that isn't caught by
    an <code>expectOne</code> or a <code>match</code>, that test will fail.
    I would recommend using this in all your test suites that are testing HTTP requests.
  </p>

  <p>
    I couldn't think of a good way of making this work with the lights though,
    so you can just look in the HttpService spec and see how it works I guess.
  </p>
</section>

<h2>Testing without URLs</h2>

<section>
  <p>
    Sometimes, you're not interested in the exact URL of the request being made -
    you just want to check that a request matching some criteria was met. To do 
    this, you can pass a function to <code>expectOne</code>, instead of a string.
    It will expct a request that makes the function return <code>true</code>
  </p>

  <pre><code>
it('should send cookies', () => &#123;
  myService.sendRequest().subscribe();
  const details = http.expectOne(request => request.headers.get('Cookie').length > 0);
});
  </code></pre>

  <p>
    Our example service has a function that checks if the user is old enough to do 
    something. You pass in a birthday, and it calls an API. The birthday is passed in 
    as an object with day, month and year fields. The API is expecting the birthday in 
    the format yyyy/m/d. Your task is to test that it's sending the correct format. 
  </p>

  <app-hint-box>
    <span title>A possible solution</span>
    <div answer>
      <pre><code>
it('it should send a date, in the format month/day', () => &#123;
  service.amIOldEnough(&#123; day: '3', month: '8', year: '1980'}).subscribe();
  http.expectOne(request => request.url.includes('1980/8/3'));
});
      </code></pre>
    </div>
  </app-hint-box>
</section>

<h2>Sending responses</h2>

<section>
  <p>
    Testing all these requests is all well and good, but, often, your service needs to 
    do something with a response before it returns it, and you want to test that it's 
    doing that correctly. In order to do that, you need a way to send back mock responses.
    You can do this using the <code>flush</code> method of the TestRequest object returned
    by <code>expectOne</code>
  </p>

  <pre><code>
it('returns the bill amount', () => &#123;
  const accountNumber = 123;
  const response = &#123;
    amount: 45,
    dueDate: '2020/12/31'
  };

  service.getBillAmount(accountNumber).subscribe(response => {
    expect(response).toBe(45);
  });
  const request = http.expectOne(`/billingInfo/${accountNumber}`);
  request.flush(response);
});
  </code></pre>

  <p>
    You can also setup a less judgemental matcher. The <code>match</code>
    method works much like <code>expectOne</code>, except that it doesn't 
    expect one. It's handy if you need to deal with multiple requests to 
    the same URL. You can pass it an exact URL, or a function, just like 
    with <code>expectOne</code>
  </p>

  <p>
    Imagine this <code>getTotal</code> calls a bunch of URLs and adds up 
    the results. This is a very contrived example, obviously. 
    <code>match</code> will return the list of requests, allowing you to
    respond to them as you will. Unfortunately, you need to all <code>match</code>
    <i>after</i> you make the HTTP request, so you can't put it in a 
    <code>beforeEach</code> block, which seems like it would have been handy.
  </p>

  <pre><code>
    it('aggregate the results', () => {
      service.getTotal().subscribe(total => {
        expect(total).toBe(4);
      });

      const tests = http.match(test => test.request.url.startsWith('/getNumberOf'));
      tests.forEach(test => test.flush({ total: 2 }));
    });
  </code></pre>

  <p>
    I've named the return variable <code>test</code> here, rather than <code>request</code>
    like I did previously, because I wanted to avoid having <code>request.request</code> in 
    the match function. Obviously, you can do what you want, if you're ok with that kind of thing.
  </p>
</section>

<h2>Handling errors</h2>


- given a valid response, make sure the service does the right thing
- given an error response, make sure the service does the right thing